<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/header.jpg?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/header.jpg?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="linux,redis,java,mysql,IO,多路复用" />










<meta name="description" content="网站描述">
<meta property="og:type" content="website">
<meta property="og:title" content="study">
<meta property="og:url" content="https://kuangai.github.io/index.html">
<meta property="og:site_name" content="study">
<meta property="og:description" content="网站描述">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="wsc">
<meta property="article:tag" content="算法">
<meta property="article:tag" content="设计模式">
<meta property="article:tag" content="java">
<meta property="article:tag" content="linux">
<meta property="article:tag" content="netty">
<meta property="article:tag" content="jvm">
<meta property="article:tag" content="Spring">
<meta property="article:tag" content="springboot">
<meta property="article:tag" content="elasticsearch">
<meta property="article:tag" content="mysql">
<meta property="article:tag" content="redis">
<meta property="article:tag" content="mybatis-plus">
<meta property="article:tag" content="Hibernate">
<meta property="article:tag" content="shell">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://kuangai.github.io/"/>





  <title>study - forever</title>
  








<meta name="generator" content="Hexo 4.2.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">study</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">forever</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-首页">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-归档">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-分类">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-标签">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-关于">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://kuangai.github.io/2020/07/31/MySQL%E7%9A%84in%E5%92%8Cexist/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="wsc">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="study">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/07/31/MySQL%E7%9A%84in%E5%92%8Cexist/" itemprop="url">MySQL的in和exist</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-07-31T16:08:00+08:00">
                2020-07-31
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/mysql/" itemprop="url" rel="index">
                    <span itemprop="name">mysql</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="in"><a href="#in" class="headerlink" title="in"></a>in</h1><p>先执行in里的语句，后执行外层语句。<br>相当于使用外层与内层语句关联查询。<br>可以用到索引</p>
<h1 id="exist"><a href="#exist" class="headerlink" title="exist"></a>exist</h1><p>先执行外层语句，再遍历外层结果集，对每一行执行exist里的语句。<br>相当于循环。<br>可以用到索引</p>
<ul>
<li>外层结果集小—使用exist</li>
<li>内层结果集小—使用in</li>
</ul>
<h1 id="not-in"><a href="#not-in" class="headerlink" title="not in"></a>not in</h1><p>不走索引</p>
<h1 id="not-exists"><a href="#not-exists" class="headerlink" title="not exists"></a>not exists</h1><p>可走索引</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://kuangai.github.io/2020/07/29/AOF%E6%8C%81%E4%B9%85%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="wsc">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="study">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/07/29/AOF%E6%8C%81%E4%B9%85%E5%8C%96/" itemprop="url">AOF持久化</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-07-29T21:08:00+08:00">
                2020-07-29
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/redis/" itemprop="url" rel="index">
                    <span itemprop="name">redis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>转：<a href="https://cloud.tencent.com/developer/article/1582654" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1582654</a></p>
<p>RDB持久化是将进程数据写入文件，而AOF持久化(即Append Only File持久化)，则是将Redis执行的每次写命令记录到单独的日志文件中（有点像MySQL的binlog）；当Redis重启时再次执行AOF文件中的命令来恢复数据。<br>与RDB相比，AOF的实时性更好，因此已成为主流的持久化方案。</p>
<ol>
<li>开启AOF<br>Redis服务器默认开启RDB，关闭AOF；要开启AOF，需要在配置文件中配置：</li>
</ol>
<p>appendonly yes<br>2. 执行流程<br>由于需要记录Redis的每条写命令，因此AOF不需要触发，下面介绍AOF的执行流程。<br> AOF的执行流程包括：<br> 命令追加(append)：将Redis的写命令追加到缓冲区aof_buf；<br> 文件写入(write)和文件同步(sync)：根据不同的同步策略将aof_buf中的内容同步到硬盘；<br> 文件重写(rewrite)：定期重写AOF文件，达到压缩的目的。</p>
<p>1) 命令追加(append)<br>Redis先将写命令追加到缓冲区，而不是直接写入文件，主要是为了避免每次有写命令都直接写入硬盘，导致硬盘IO成为Redis负载的瓶颈。<br> 命令追加的格式是Redis命令请求的协议格式，它是一种纯文本格式，具有兼容性好、可读性强、容易处理、操作简单避免二次开销等优点；具体格式略。在AOF文件中，除了用于指定数据库的select命令（如select 0 为选中0号数据库）是由Redis添加的，其他都是客户端发送来的写命令。</p>
<p>2) 文件写入(write)和文件同步(sync)<br>Redis提供了多种AOF缓存区的同步文件策略，策略涉及到操作系统的write函数和fsync函数，说明如下：<br> 为了提高文件写入效率，在现代操作系统中，当用户调用write函数将数据写入文件时，操作系统通常会将数据暂存到一个内存缓冲区里，当缓冲区被填满或超过了指定时限后，才真正将缓冲区的数据写入到硬盘里。这样的操作虽然提高了效率，但也带来了安全问题：如果计算机停机，内存缓冲区中的数据会丢失；因此系统同时提供了fsync、fdatasync等同步函数，可以强制操作系统立刻将缓冲区中的数据写入到硬盘里，从而确保数据的安全性。</p>
<p>AOF缓存区的同步文件策略由参数appendfsync控制，各个值的含义如下：<br> always：命令写入aof_buf后立即调用系统fsync操作同步到AOF文件，fsync完成后线程返回。这种情况下，每次有写命令都要同步到AOF文件，硬盘IO成为性能瓶颈，Redis只能支持大约几百TPS写入，严重降低了Redis的性能；即便是使用固态硬盘（SSD），每秒大约也只能处理几万个命令，而且会大大降低SSD的寿命。<br> no：命令写入aof_buf后调用系统write操作，不对AOF文件做fsync同步；同步由操作系统负责，通常同步周期为30秒。这种情况下，文件同步的时间不可控，且缓冲区中堆积的数据会很多，数据安全性无法保证。<br> everysec：命令写入aof_buf后调用系统write操作，write完成后线程返回；fsync同步文件操作由专门的线程每秒调用一次。everysec是前述两种策略的折中，是性能和数据安全性的平衡，因此是Redis的默认配置，也是我们推荐的配置。</p>
<p>3) 文件重写(rewrite)<br>随着时间流逝，Redis服务器执行的写命令越来越多，AOF文件也会越来越大；过大的AOF文件不仅会影响服务器的正常运行，也会导致数据恢复需要的时间过长。</p>
<p>文件重写是指定期重写AOF文件，减小AOF文件的体积。需要注意的是，AOF重写是把Redis进程内的数据转化为写命令，同步到新的AOF文件；不会对旧的AOF文件进行任何读取、写入操作!</p>
<p>关于文件重写需要注意的另一点是：对于AOF持久化来说，文件重写虽然是强烈推荐的，但并不是必须的；即使没有文件重写，数据也可以被持久化并在Redis启动的时候导入；因此在一些实现中，会关闭自动的文件重写，然后通过定时任务在每天的某一时刻定时执行。</p>
<p>文件重写之所以能够压缩AOF文件，原因在于：<br> 过期的数据不再写入文件<br> 无效的命令不再写入文件：如有些数据被重复设值(set mykey v1, set mykey v2)、有些数据被删除了(sadd myset v1, del myset)等等<br> 多条命令可以合并为一个：如sadd myset v1, sadd myset v2, sadd myset v3可以合并为sadd myset v1 v2 v3。不过为了防止单条命令过大造成客户端缓冲区溢出，对于list、set、hash、zset类型的key，并不一定只使用一条命令；而是以某个常量为界将命令拆分为多条。这个常量在redis.h/REDIS_AOF_REWRITE_ITEMS_PER_CMD中定义，不可更改，3.0版本中值是64。</p>
<p>文件重写的触发<br>文件重写的触发<br> 文件重写的触发，分为手动触发和自动触发：<br> 手动触发：直接调用bgrewriteaof命令，该命令的执行与bgsave有些类似：都是fork子进程进行具体的工作，且都只有在fork时阻塞。</p>
<p>自动触发：根据auto-aof-rewrite-min-size和auto-aof-rewrite-percentage参数，以及aof_current_size和aof_base_size状态确定触发时机。<br> auto-aof-rewrite-min-size：执行AOF重写时，文件的最小体积，默认值为64MB。<br> auto-aof-rewrite-percentage：执行AOF重写时，当前AOF大小(即aof_current_size)和上一次重写时AOF大小(aof_base_size)的比值。<br> 其中，参数可以通过config get命令查看：</p>
<p>这里写图片描述</p>
<p>状态可以通过info persistence查看：</p>
<p>这里写图片描述</p>
<p>只有当auto-aof-rewrite-min-size和auto-aof-rewrite-percentage两个参数同时满足时，才会自动触发AOF重写，即bgrewriteaof操作。</p>
<p>这里写图片描述</p>
<p>关于文件重写的流程，有两点需要特别注意：<br> (1)重写由父进程fork子进程进行；<br> (2)重写期间Redis执行的写命令，需要追加到新的AOF文件中，为此Redis引入了aof_rewrite_buf缓存。</p>
<p>对照上图，文件重写的流程如下：<br>Redis父进程首先判断当前是否存在正在执行 bgsave/bgrewriteaof的子进程，如果存在则bgrewriteaof命令直接返回，如果存在bgsave命令则等bgsave执行完成后再执行。前面曾介绍过，这个主要是基于性能方面的考虑。<br>父进程执行fork操作创建子进程，这个过程中父进程是阻塞的。<br> 3.1) 父进程fork后，bgrewriteaof命令返回”Background append only file rewrite started”信息并不再阻塞父进程，并可以响应其他命令。Redis的所有写命令依然写入AOF缓冲区，并根据appendfsync策略同步到硬盘，保证原有AOF机制的正确。<br> 3.2) 由于fork操作使用写时复制技术，子进程只能共享fork操作时的内存数据。由于父进程依然在响应命令，因此Redis使用AOF重写缓冲区(图中的aof_rewrite_buf)保存这部分数据，防止新AOF文件生成期间丢失这部分数据。也就是说，bgrewriteaof执行期间，Redis的写命令同时追加到aof_buf和aof_rewirte_buf两个缓冲区。<br>子进程根据内存快照，按照命令合并规则写入到新的AOF文件。<br> 5.1) 子进程写完新的AOF文件后，向父进程发信号，父进程更新统计信息，具体可以通过info persistence查看。<br> 5.2) 父进程把AOF重写缓冲区的数据写入到新的AOF文件，这样就保证了新AOF文件所保存的数据库状态和服务器当前状态一致。<br> 5.3) 使用新的AOF文件替换老文件，完成AOF重写。<br>3. 启动时加载<br>前面提到过，当AOF开启时，Redis启动时会优先载入AOF文件来恢复数据；只有当AOF关闭时，才会载入RDB文件恢复数据。<br> 当AOF开启，且AOF文件存在时，Redis启动日志：</p>
<p>这里写图片描述</p>
<p>当AOF开启，但AOF文件不存在时，即使RDB文件存在也不会加载(更早的一些版本可能会加载，但3.0不会)，Redis启动日志如下：</p>
<p>文件校验<br>与载入RDB文件类似，Redis载入AOF文件时，会对AOF文件进行校验，如果文件损坏，则日志中会打印错误，Redis启动失败。但如果是AOF文件结尾不完整(机器突然宕机等容易导致文件尾部不完整)，且aof-load-truncated参数开启，则日志中会输出警告，Redis忽略掉AOF文件的尾部，启动成功。aof-load-truncated参数默认是开启的：</p>
<p>伪客户端<br>因为Redis的命令只能在客户端上下文中执行，而载入AOF文件时命令是直接从文件中读取的，并不是由客户端发送；因此Redis服务器在载入AOF文件之前，会创建一个没有网络连接的客户端，之后用它来执行AOF文件中的命令，命令执行的效果与带网络连接的客户端完全一样。</p>
<p>AOF常用配置总结<br>下面是AOF常用的配置项，以及默认值；前面介绍过的这里不再详细介绍。<br> appendonly no：是否开启AOF<br> appendfilename “appendonly.aof”：AOF文件名<br> dir ./：RDB文件和AOF文件所在目录<br> appendfsync everysec：fsync持久化策略<br> no-appendfsync-on-rewrite no：AOF重写期间是否禁止fsync；如果开启该选项，可以减轻文件重写时CPU和硬盘的负载（尤其是硬盘），但是可能会丢失AOF重写期间的数据；需要在负载和安全性之间进行平衡<br> auto-aof-rewrite-percentage 100：文件重写触发条件之一<br> auto-aof-rewrite-min-size 64mb：文件重写触发提交之一<br> aof-load-truncated yes：如果AOF文件结尾损坏，Redis启动时是否仍载入AOF文件</p>
<p>方案选择与常见问题（重点）<br>在介绍持久化策略之前，首先要明白无论是RDB还是AOF，持久化的开启都是要付出性能方面代价的：对于RDB持久化，一方面是bgsave在进行fork操作时Redis主进程会阻塞，另一方面，子进程向硬盘写数据也会带来IO压力；对于AOF持久化，向硬盘写数据的频率大大提高(everysec策略下为秒级)，IO压力更大，甚至可能造成AOF追加阻塞问题（后面会详细介绍这种阻塞），此外，AOF文件的重写与RDB的bgsave类似，会有fork时的阻塞和子进程的IO压力问题。相对来说，由于AOF向硬盘中写数据的频率更高，因此对Redis主进程性能的影响会更大。</p>
<p>实际生产环境中，根据数据量、应用对数据的安全要求、预算限制等不同情况，会有各种各样的持久化策略；如完全不使用任何持久化、使用RDB或AOF的一种，或同时开启RDB和AOF持久化等。此外，持久化的选择必须与Redis的主从策略一起考虑，因为主从复制与持久化同样具有数据备份的功能，而且主机master和从机slave可以独立的选择持久化方案。</p>
<p>下面分场景来讨论持久化策略的选择，下面的讨论也只是作为参考，实际方案可能更复杂更具多样性。<br> （1）如果Redis中的数据完全丢弃也没有关系（如Redis完全用作DB层数据的cache），那么无论是单机，还是主从架构，都可以不进行任何持久化。<br> （2）在单机环境下（对于个人开发者，这种情况可能比较常见），如果可以接受十几分钟或更多的数据丢失，选择RDB对Redis的性能更加有利；如果只能接受秒级别的数据丢失，应该选择AOF。<br> （3）但在多数情况下，我们都会配置主从环境，slave的存在既可以实现数据的热备，也可以进行读写分离分担Redis读请求，以及在master宕掉后继续提供服务。</p>
<p>在这种情况下，一种可行的做法是：<br> master：完全关闭持久化（包括RDB和AOF），这样可以让master的性能达到最好<br> slave：关闭RDB，开启AOF（如果对数据安全要求不高，开启RDB关闭AOF也可以），并定时对持久化文件进行备份（如备份到其他文件夹，并标记好备份的时间）；然后关闭AOF的自动重写，然后添加定时任务，在每天Redis闲时（如凌晨12点）调用bgrewriteaof。</p>
<p>这里需要解释一下，为什么开启了主从复制，可以实现数据的热备份，还需要设置持久化呢？因为在一些特殊情况下，主从复制仍然不足以保证数据的安全，例如：<br> master和slave进程同时停止：考虑这样一种场景，如果master和slave在同一栋大楼或同一个机房，则一次停电事故就可能导致master和slave机器同时关机，Redis进程停止；如果没有持久化，则面临的是数据的完全丢失。<br> master误重启：考虑这样一种场景，master服务因为故障宕掉了，如果系统中有自动拉起机制（即检测到服务停止后重启该服务）将master自动重启，由于没有持久化文件，那么master重启后数据是空的，slave同步数据也变成了空的；如果master和slave都没有持久化，同样会面临数据的完全丢失。需要注意的是，即便是使用了哨兵(关于哨兵后面会有文章介绍)进行自动的主从切换，也有可能在哨兵轮询到master之前，便被自动拉起机制重启了。因此，应尽量避免“自动拉起机制”和“不做持久化”同时出现。<br> （4）异地灾备：上述讨论的几种持久化策略，针对的都是一般的系统故障，如进程异常退出、宕机、断电等，这些故障不会损坏硬盘。但是对于一些可能导致硬盘损坏的灾难情况，如火灾地震，就需要进行异地灾备。例如对于单机的情形，可以定时将RDB文件或重写后的AOF文件，通过scp拷贝到远程机器，如阿里云、AWS等；对于主从的情形，可以定时在master上执行bgsave，然后将RDB文件拷贝到远程机器，或者在slave上执行bgrewriteaof重写AOF文件后，将AOF文件拷贝到远程机器上。一般来说，由于RDB文件文件小、恢复快，因此灾难恢复常用RDB文件；异地备份的频率根据数据安全性的需要及其他条件来确定，但最好不要低于一天一次。</p>
<p>（4）异地灾备：上述讨论的几种持久化策略，针对的都是一般的系统故障，如进程异常退出、宕机、断电等，这些故障不会损坏硬盘。但是对于一些可能导致硬盘损坏的灾难情况，如火灾地震，就需要进行异地灾备。例如对于单机的情形，可以定时将RDB文件或重写后的AOF文件，通过scp拷贝到远程机器，如阿里云、AWS等；对于主从的情形，可以定时在master上执行bgsave，然后将RDB文件拷贝到远程机器，或者在slave上执行bgrewriteaof重写AOF文件后，将AOF文件拷贝到远程机器上。一般来说，由于RDB文件文件小、恢复快，因此灾难恢复常用RDB文件；异地备份的频率根据数据安全性的需要及其他条件来确定，但最好不要低于一天一次。</p>
<p>fork阻塞：CPU的阻塞<br>在Redis的实践中，众多因素限制了Redis单机的内存不能过大，例如：<br> 当面对请求的暴增，需要从库扩容时，Redis内存过大会导致扩容时间太长；<br> 当主机宕机时，切换主机后需要挂载从库，Redis内存过大导致挂载速度过慢；<br> 以及持久化过程中的fork操作，下面详细说明。<br> 首先说明一下fork操作：<br> 父进程通过fork操作可以创建子进程；子进程创建后，父子进程共享代码段，不共享进程的数据空间，但是子进程会获得父进程的数据空间的副本。在操作系统fork的实际实现中，基本都采用了写时复制技术，即在父/子进程试图修改数据空间之前，父子进程实际上共享数据空间；但是当父/子进程的任何一个试图修改数据空间时，操作系统会为修改的那一部分(内存的一页)制作一个副本。<br> 虽然fork时，子进程不会复制父进程的数据空间，但是会复制内存页表（页表相当于内存的索引、目录）；父进程的数据空间越大，内存页表越大，fork时复制耗时也会越多。</p>
<p>在Redis中，无论是RDB持久化的bgsave，还是AOF重写的bgrewriteaof，都需要fork出子进程来进行操作。如果Redis内存过大，会导致fork操作时复制内存页表耗时过多；而Redis主进程在进行fork时，是完全阻塞的，也就意味着无法响应客户端的请求，会造成请求延迟过大。<br> 对于不同的硬件、不同的操作系统，fork操作的耗时会有所差别，一般来说，如果Redis单机内存达到了10GB，fork时耗时可能会达到百毫秒级别（如果使用Xen虚拟机，这个耗时可能达到秒级别）。因此，一般来说Redis单机内存一般要限制在10GB以内；不过这个数据并不是绝对的，可以通过观察线上环境fork的耗时来进行调整。观察的方法如下：执行命令info stats，查看latest_fork_usec的值，单位为微秒。<br> 为了减轻fork操作带来的阻塞问题，除了控制Redis单机内存的大小以外，还可以适度放宽AOF重写的触发条件、选用物理机或高效支持fork操作的虚拟化技术等，例如使用Vmware或KVM虚拟机，不要使用Xen虚拟机。</p>
<p>AOF追加阻塞：硬盘的阻塞<br>前面提到过，在AOF中，如果AOF缓冲区的文件同步策略为everysec，则：在主线程中，命令写入aof_buf后调用系统write操作，write完成后主线程返回；fsync同步文件操作由专门的文件同步线程每秒调用一次。<br> 这种做法的问题在于，如果硬盘负载过高，那么fsync操作可能会超过1s；如果Redis主线程持续高速向aof_buf写入命令，硬盘的负载可能会越来越大，IO资源消耗更快；如果此时Redis进程异常退出，丢失的数据也会越来越多，可能远超过1s。<br> 为此，Redis的处理策略是这样的：主线程每次进行AOF会对比上次fsync成功的时间；如果距上次不到2s，主线程直接返回；如果超过2s，则主线程阻塞直到fsync同步完成。因此，如果系统硬盘负载过大导致fsync速度太慢，会导致Redis主线程的阻塞；此外，使用everysec配置，AOF最多可能丢失2s的数据，而不是1s。</p>
<p>AOF追加阻塞问题定位的方法：<br> （1）监控info Persistence中的aof_delayed_fsync：当AOF追加阻塞发生时（即主线程等待fsync而阻塞），该指标累加。<br> （2）AOF阻塞时的Redis日志：<br> Asynchronous AOF fsync is taking too long (disk is busy?). Writing the AOF buffer without waiting for fsync to complete, this may slow down Redis.<br> （3）如果AOF追加阻塞频繁发生，说明系统的硬盘负载太大；可以考虑更换IO速度更快的硬盘，或者通过IO监控分析工具对系统的IO负载进行分析，如iostat（系统级io）、iotop（io版的top）、pidstat等。</p>
<p>总结<br>本文主要内容可以总结如下：<br> 1、持久化在Redis高可用中的作用：数据备份，与主从复制相比强调的是由内存到硬盘的备份。<br> 2、RDB持久化：将数据快照备份到硬盘；介绍了其触发条件（包括手动出发和自动触发）、执行流程、RDB文件等，特别需要注意的是文件保存操作由fork出的子进程来进行。<br> 3、AOF持久化：将执行的写命令备份到硬盘（类似于MySQL的binlog），介绍了其开启方法、执行流程等，特别需要注意的是文件同步策略的选择（everysec）、文件重写的流程。<br> 4、一些现实的问题：包括如何选择持久化策略，以及需要注意的fork阻塞、AOF追加阻塞等。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://kuangai.github.io/2020/07/29/Untitled/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="wsc">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="study">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/07/29/Untitled/" itemprop="url">redis4.0之RDB-AOF混合持久化</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-07-29T20:18:00+08:00">
                2020-07-29
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/redis/" itemprop="url" rel="index">
                    <span itemprop="name">redis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>转载：<a href="https://developer.aliyun.com/article/193034" target="_blank" rel="noopener">https://developer.aliyun.com/article/193034</a><br>简介： redis有两种持久化的方式——RDB和AOF，RDB是一份内存快照，AOF则为可回放的命令日志，他们两个各有特点也相互独立。4.0开始允许使用RDB-AOF混合持久化的方式，结合了两者的优点，通过aof-use-rdb-preamble配置项可以打开混合开关。<br>前言<br>redis有两种持久化的方式——RDB和AOF其中RDB是一份内存快照AOF则为可回放的命令日志他们两个各有特点也相互独立。4.0开始允许使用RDB-AOF混合持久化的方式结合了两者的优点通过aof-use-rdb-preamble配置项可以打开混合开关。</p>
<p>RDB V.S. AOF</p>
<ol>
<li><p>RDB<br>RDB文件本质上是一份内存快照保存了创建RDB文件那个时间点的redis全量数据具有数据文件小创建、恢复快的优点但是由于快照的特性无法保存创建RDB之后的增量数据。</p>
</li>
<li><p>AOF<br>AOF文件本质上是一份执行日志保存所有对redis进行更改的命令增量数据也就随命令写入AOF文件刷盘的策略由配置项appendfsync控制可以选择”everysec”或”always”。</p>
</li>
</ol>
<p>AOF文件基本上是human-readable的文本所以其体积相对较大在从AOF文件恢复数据时就是做日志回放执行AOF文件中记录的所有命令所以相对RDB而言恢复耗时较长。</p>
<p>随着redis的运行AOF文件会不断膨胀由aofrewrite机制来防止磁盘空间被撑满详见上一篇文章《redis4.0之利用管道优化aofrewrite》。</p>
<p>RDB-AOF混合持久化<br>细细想来aofrewrite时也是先写一份全量数据到新AOF文件中再追加增量只不过全量数据是以redis命令的格式写入。那么是否可以先以RDB格式写入全量数据再追加增量日志呢这样既可以提高aofrewrite和恢复速度也可以减少文件大小还可以保证数据的完毕性整合RDB和AOF的优点那么现在4.0实现了这一特性——RDB-AOF混合持久化。</p>
<p>aofrewrite<br>综上所述RDB-AOF混合持久化体现在aofrewrite时那么我们就从这里开始来看4.0是如何实现的</p>
<p>回忆下aofrewrite的过程</p>
<p>无论是serverCron触发或者执行BGREWRITEAOF命令最终redis都会走到rewriteAppendOnlyFileBackground()</p>
<p>rewriteAppendOnlyFileBackground函数会fork子进程子进程进入rewriteAppendOnlyFile函数来生成新的AOF文件混合持久化就从这里开始<br>int rewriteAppendOnlyFile(char *filename) {<br>    …<br>    if (server.aof_use_rdb_preamble) {<br>        int error;<br>        if (rdbSaveRio(&amp;aof,&amp;error,RDB_SAVE_AOF_PREAMBLE,NULL) == C_ERR) {<br>            errno = error;<br>            goto werr;<br>        }<br>    } else {<br>        if (rewriteAppendOnlyFileRio(&amp;aof) == C_ERR) goto werr;<br>    }<br>    …<br>}<br>可以看到当混合持久化开关打开时就会进入rdbSaveRio函数先以RDB格式来保存全量数据</p>
<p>前文说道子进程在做aofrewrite时会通过管道从父进程读取增量数据并缓存下来</p>
<p>那么在以RDB格式保存全量数据时也会从管道读取数据并不会造成管道阻塞<br>int rdbSaveRio(rio *rdb, int *error, int flags, rdbSaveInfo *rsi) {<br>    …<br>    snprintf(magic,sizeof(magic),”REDIS%04d”,RDB_VERSION);<br>    if (rdbWriteRaw(rdb,magic,9) == -1) goto werr;<br>    if (rdbSaveInfoAuxFields(rdb,flags,rsi) == -1) goto werr;<br>首先把RDB的版本注意不是redis的版本和辅助域写入文件<br>    for (j = 0; j &lt; server.dbnum; j++) {<br>        redisDb *db = server.db+j;<br>        dict *d = db-&gt;dict;<br>        if (dictSize(d) == 0) continue;<br>        di = dictGetSafeIterator(d);<br>        if (!di) return C_ERR;</p>
<pre><code>/* Write the SELECT DB opcode */
if (rdbSaveType(rdb,RDB_OPCODE_SELECTDB) == -1) goto werr;
if (rdbSaveLen(rdb,j) == -1) goto werr;

/* Write the RESIZE DB opcode. We trim the size to UINT32_MAX, which
 * is currently the largest type we are able to represent in RDB sizes.
 * However this does not limit the actual size of the DB to load since
 * these sizes are just hints to resize the hash tables. */
uint32_t db_size, expires_size;
db_size = (dictSize(db-&gt;dict) &lt;= UINT32_MAX) ?
                        dictSize(db-&gt;dict) :
                        UINT32_MAX;
expires_size = (dictSize(db-&gt;expires) &lt;= UINT32_MAX) ?
                        dictSize(db-&gt;expires) :
                        UINT32_MAX;
if (rdbSaveType(rdb,RDB_OPCODE_RESIZEDB) == -1) goto werr;
if (rdbSaveLen(rdb,db_size) == -1) goto werr;
if (rdbSaveLen(rdb,expires_size) == -1) goto werr;</code></pre><p>然后遍历DB先把dbnum和db_size、expires_size写入文件<br>        /* Iterate this DB writing every entry */<br>        while((de = dictNext(di)) != NULL) {<br>            sds keystr = dictGetKey(de);<br>            robj key, *o = dictGetVal(de);<br>            long long expire;</p>
<pre><code>        initStaticStringObject(key,keystr);
        expire = getExpire(db,&amp;key);
        if (rdbSaveKeyValuePair(rdb,&amp;key,o,expire,now) == -1) goto werr;

        /* When this RDB is produced as part of an AOF rewrite, move
         * accumulated diff from parent to child while rewriting in
         * order to have a smaller final write. */
        if (flags &amp; RDB_SAVE_AOF_PREAMBLE &amp;&amp;
            rdb-&gt;processed_bytes &gt; processed+AOF_READ_DIFF_INTERVAL_BYTES)
        {
            processed = rdb-&gt;processed_bytes;
            aofReadDiffFromParent();
        }
    }
    dictReleaseIterator(di);
}
di = NULL; /* So that we don&apos;t release it again on error. */</code></pre><p>在当前DB中遍历所有的key把key-value对及过期时间如果有设置的话写入文件</p>
<p>这里小插曲一下在rdbSaveKeyValuePair函数中会判断expire是否已经到了过期时间如果已经过期就不会写入文件</p>
<p>同时如果flags标记了RDB_SAVE_AOF_PREAMBLE的话说明是在aofrewrite且开启了RDB-AOF混合开关此时就会从父进程去读取增量数据了<br>    /* EOF opcode */<br>    if (rdbSaveType(rdb,RDB_OPCODE_EOF) == -1) goto werr;</p>
<pre><code>/* CRC64 checksum. It will be zero if checksum computation is disabled, the
 * loading code skips the check in this case. */
cksum = rdb-&gt;cksum;
memrev64ifbe(&amp;cksum);
if (rioWrite(rdb,&amp;cksum,8) == 0) goto werr;
return C_OK;</code></pre><p>}<br>最后把代表RDB格式结束的RDB_OPCODE_EOF标记和校验和写入文件<br>RDB-AOF混合持久化的RDB部分到此结束rdbSaveRio函数运行完后返回rewriteAppendOnlyFile继续把增量数据写入AOF文件。</p>
<p>也就是说AOF文件的前半段是RDB格式的全量数据后半段是redis命令格式的增量数据。</p>
<p>数据恢复<br>当appendonly配置项为no时redis启动后会去加载RDB文件以RDB格式来解析RDB文件自然没有问题。</p>
<p>而appendonly配置项为yes时redis启动后会加载AOF文件来恢复数据如果持久化时开启了RDB-AOF混合开关那么AOF文件的前半段就是RDB格式此时要如何正确加载数据呢</p>
<p>一切数据都逃不过协议二字不以正确的协议存储和解析那就是乱码既然允许RDB-AOF混合持久化就要能够识别并恢复数据这一节我们来介绍如何以正确的姿势来恢复数据。</p>
<p>加载AOF文件的入口为loadAppendOnlyFile</p>
<p>int loadAppendOnlyFile(char <em>filename) {<br>    …<br>    /</em> Check if this AOF file has an RDB preamble. In that case we need to<br>     * load the RDB file and later continue loading the AOF tail. <em>/<br>    char sig[5]; /</em> “REDIS” <em>/<br>    if (fread(sig,1,5,fp) != 5 || memcmp(sig,”REDIS”,5) != 0) {<br>        /</em> No RDB preamble, seek back at 0 offset. <em>/<br>        if (fseek(fp,0,SEEK_SET) == -1) goto readerr;<br>    } else {<br>        /</em> RDB preamble. Pass loading the RDB functions. */<br>        rio rdb;</p>
<pre><code>    serverLog(LL_NOTICE,&quot;Reading RDB preamble from AOF file...&quot;);
    if (fseek(fp,0,SEEK_SET) == -1) goto readerr;
    rioInitWithFile(&amp;rdb,fp);
    if (rdbLoadRio(&amp;rdb,NULL) != C_OK) {
        serverLog(LL_WARNING,&quot;Error reading the RDB preamble of the AOF file, AOF loading aborted&quot;);
        goto readerr;
    } else {
        serverLog(LL_NOTICE,&quot;Reading the remaining AOF tail...&quot;);
    }
}
...</code></pre><p>}<br>打开AOF文件之后首先读取5个字符如果是”REDIS”那么就说明这是一个混合持久化的AOF文件正确的RDB格式一定是以”REDIS”开头而纯AOF格式则一定以”*”开头此时就会进入rdbLoadRio函数来加载数据。</p>
<p>rdbLoadRio函数此处就不详细展开了就是以约定好的协议解析文件内容直至遇到RDB_OPCODE_EOF结束标记返回loadAppendOnlyFile函数继续以AOF格式解析文件直到结束整个加载过程完成。</p>
<p>附录</p>
<ol>
<li>RDB格式的文件<br>我们先向redis写入一些数据并生成RDB文件</li>
</ol>
<p>$redis-cli<br>127.0.0.1:6379&gt; set foo bar<br>OK<br>127.0.0.1:6379&gt; expire foo 60<br>(integer) 1<br>127.0.0.1:6379&gt; select 2<br>OK<br>127.0.0.1:6379[2]&gt; set foo bar<br>OK<br>127.0.0.1:6379[2]&gt; bgsave<br>Background saving started<br>看下RDB文件内容</p>
<p>$cat dump.rdb<br>REDIS0008    redis-ver4.0.1<br>redis-bits@ctimeYused-mem<br>                                aof-preamblerepl-id(484f9d49a700c4b9b136f0fd40d2d6e5a8460438<br>                                                                                               repl-offa;^foobarfoobar^KJ_U<br>OMG…一堆乱码隐约可以看到一些和redis相关的字符串为了更直观的感受下RDB的内容我们用redis自带的工具redis-check-rdb来看下</p>
<p>redis-check-rdb dump.rdb<br>[offset 0] Checking RDB file dump.rdb<br>[offset 26] AUX FIELD redis-ver = ‘4.0.1’<br>[offset 40] AUX FIELD redis-bits = ‘64’<br>[offset 52] AUX FIELD ctime = ‘1504234774’<br>[offset 67] AUX FIELD used-mem = ‘2139016’<br>[offset 83] AUX FIELD aof-preamble = ‘0’<br>[offset 133] AUX FIELD repl-id = ‘484f9d49a700c4b9b136f0fd40d2d6e5a8460438’<br>[offset 148] AUX FIELD repl-offset = ‘0’<br>[offset 150] Selecting DB ID 0<br>[offset 173] Selecting DB ID 2<br>[offset 194] Checksum OK<br>[offset 194] \o/ RDB looks OK! \o/<br>[info] 2 keys read<br>[info] 1 expires<br>[info] 0 already expired<br>这下就好看多了首先可以看到是一些AUX FIELD辅助域4.0特有用来配合全新的主从同步方式PSYNC2后面会专门来介绍PSYNC2然后可以看到DB0和DB2是有内容的Checksum也OK最后是说一共有2个key其中一个设置了过期时间到目前为止还都没有过期。</p>
<ol start="2">
<li>AOF格式的文件<br>同样的数据我们来看下在AOF文件中是如何保存的</li>
</ol>
<p>$cat appendonly.aof<br>*2<br>$6<br>SELECT<br>$1<br>0<br>*3<br>$3<br>set<br>$3<br>foo<br>$3<br>bar<br>*3<br>$9<br>PEXPIREAT<br>$3<br>foo<br>$13<br>1504255377087<br>*2<br>$6<br>SELECT<br>$1<br>2<br>*3<br>$3<br>set<br>$3<br>foo<br>$3<br>bar<br>很明显就是一条一条redis命令。</p>
<ol start="3">
<li>RDB-AOF混和持久化的文件<br>最后来看下RDB-AOF混和持久化的文件。</li>
</ol>
<p>首先打开混合开关执行BGREWRITEAOF生成RDB-AOF混合文件再追加写入一些数据</p>
<p>$redis-cli<br>127.0.0.1:6379&gt; config set aof-use-rdb-preamble yes<br>OK<br>127.0.0.1:6379&gt; BGREWRITEAOF<br>Background append only file rewriting started<br>127.0.0.1:6379&gt; set foo bar<br>OK<br>127.0.0.1:6379&gt; quit<br>再来看下此时AOF文件内容</p>
<p>$cat appendonly.aof<br>REDIS0008    redis-ver4.0.1<br>redis-bits@ctimeYused-memP<br>                                  aof-preamblerepl-id(484f9d49a700c4b9b136f0fd40d2d6e5a8460438<br>                                                                                                 repl-offsetfoobar?I    Y*2<br>$6<br>SELECT<br>$1<br>0<br>*3<br>$3<br>set<br>$3<br>foo<br>$3<br>bar<br>显而易见前半段是RDB格式的全量数据后半段是redis命令格式的增量数据。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://kuangai.github.io/2020/07/29/redis%E5%AE%9E%E7%8E%B0%E5%86%85%E5%AD%98%E5%88%86%E9%A1%B5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="wsc">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="study">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/07/29/redis%E5%AE%9E%E7%8E%B0%E5%86%85%E5%AD%98%E5%88%86%E9%A1%B5/" itemprop="url">redis实现内存分页</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-07-29T19:28:00+08:00">
                2020-07-29
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/redis/" itemprop="url" rel="index">
                    <span itemprop="name">redis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="redis实现分页的方法"><a href="#redis实现分页的方法" class="headerlink" title="redis实现分页的方法"></a>redis实现分页的方法</h2><p>每个主题下的用户的评论组装好写入Redis中，每个主题会有一个topicId，每一条评论会和topicId关联起来，大致的数据模型如下：<br>{ topicId: ‘xxxxxxxx’, comments: [ { username: ‘niuniu’, createDate: 1447747334791, content: ‘在Redis中分页’, commentId: ‘xxxxxxx’, reply: [ { content: ‘yyyyyy’ username: ‘niuniu’ }, … ] }, … ]}<br>将评论数据从MySQL查询出来组装好存到Redis后，以后每次就可以从Redis获取组装好的评论数据，从上面的数据模型可以看出数据都是key-value型数据，无疑要采用hash进行存储，但是每次拿取评论数据时需要分页而且还要按createDate字段进行排序，hash肯定是不能做到分页和排序的。</p>
<p>那么，就挨个看一下Redis所支持的数据类型：</p>
<p>1、String: 主要用于存储字符串，显然不支持分页和排序。<br>2、Hash: 主要用于存储key-value型数据，评论模型中全是key-value型数据，所以在这里Hash无疑会用到。<br>3、List: 主要用于存储一个列表，列表中的每一个元素按元素的插入时的顺序进行保存，如果我们将评论模型按createDate排好序后再插入List中，似乎就能做到排序了，而且再利用List中的LRANGE key start stop指令还能做到分页。嗯，到这里List似乎满足了我们分页和排序的要求，但是评论还会被删除，就需要更新Redis中的数据，如果每次删除评论后都将Redis中的数据全部重新写入一次，显然不够优雅，效率也会大打折扣，如果能删除指定的数据无疑会更好，而List中涉及到删除数据的就只有LPOP和RPOP这两条指令，但LPOP和RPOP只能删除列表头和列表尾的数据，不能删除指定位置的数据,(备注：其实还有 LREM命令可以做到删除，但是非常不方便)，而且当存在接口高并发访问时，这个list可能会无限延长，且里面的数据会存在很多重复，这就会影响到正常的业务，所以List也不太适合。</p>
<p>4、Set: 主要存储无序集合，无序！排除。<br>5、SortedSet: 主要存储有序集合，SortedSet的添加元素指令ZADD key score member [[score,member]…]会给每个添加的元素member绑定一个用于排序的值score，SortedSet就会根据score值的大小对元素进行排序，在这里就可以将createDate当作score用于排序，SortedSet中的指令ZREVRANGE key start stop又可以返回指定区间内的成员，可以用来做分页，SortedSet的指令ZREM key member可以根据key移除指定的成员，能满足删评论的要求，所以，SortedSet在这里是最适合的（时间复杂度O(log(N))）。</p>
<p>所以，需要用到的数据类型有SortSet和Hash，SortSet用于做分页排序，Hash用于存储具体的键值对数据。SortSet结构中将每个主题的topicId作为set的key，将与该主题关联的评论的createDate和commentId分别作为set的score和member，commentId的顺序就根据createDate的大小进行排列。<br>当需要查询某个主题某一页的评论时，就可主题的topicId通过指令zrevrange topicId (page-1)×10 (page-1)×10+perPage这样就能找出某个主题下某一页的按时间排好顺序的所有评论的commintId。page为查询第几页的页码，perPage为每页显示的条数。<br>当找到所有评论的commentId后，就可以把这些commentId作为key去Hash结构中去查询该条评论对应的内容。<br>这样就利用SortSet和Hash两种结构在Redis中达到了分页和排序的目的。</p>
<p>当然，也可以直接只使用SrotedSet类型，而不使用Hash类型，直接将评论存放在member中。<br>但为什么要将评论和排序放到不同的类型里？其中的好处是，可以对评论设置不同的排序类型，比如按时间的正反序，点赞的正反序，查看次数的正反序等。而这样只需要维护不同的SrotedSet排序，不需要维护多套评论的内容了。</p>
<p>下面是示例：</p>
<p>需要引用下面两个jar包</p>
<p>采用的jedis-2.8.1.jar</p>
<p>因为JedisPool引用了第三方类库，需要再加入 commons-pool2-2.4.2.jar</p>
<p>代码如下：</p>
<p>复制代码<br> public static void main(String[] args)<br>    {<br>        for (int i = 1; i &lt;= 100; i += 1) {<br>            // 初始化CommentId索引 SortSet<br>            RedisClient.zadd(“topicId”, i, “commentId” + i);<br>            // 初始化Comment数据 Hash<br>            RedisClient.hset(“Comment_Key”, “commentId” + i, “comment content “+ i +” …….”);<br>        }<br>        // 倒序取 从0条开始取 5条 Id 数据<br>        Set<String> sets = RedisClient.zrevrangebyscore(“topicId”, “100”, “1”, 0, 10);<br>        String[] items = new String[]{};<br>        System.out.println(sets.toString());<br>        // 根据id取comment数据<br>        List<String> list = RedisClient.hmget(“Comment_Key”, sets.toArray(items));<br>        for (String str : list) {<br>            System.out.println(str);<br>        }</p>
<pre><code>}</code></pre><p>复制代码<br>其中的RedisClient类的代码如下：</p>
<p>复制代码<br>import java.util.LinkedHashSet;<br>import java.util.List;<br>import java.util.Set;</p>
<p>import redis.clients.jedis.Jedis;<br>import redis.clients.jedis.JedisCommands;<br>import redis.clients.jedis.JedisPool;<br>import redis.clients.jedis.JedisPoolConfig;</p>
<p>/**</p>
<ul>
<li><p>Redis 客户端</p>
</li>
<li><p>/<br>public class RedisClient {</p>
<p>  private static JedisPool jedisPool;</p>
<p>  static {</p>
<pre><code>JedisPoolConfig config = new JedisPoolConfig();

config.setMaxTotal(123);
config.setMaxTotal(1024);
config.setMaxIdle(10);
config.setMaxWaitMillis(1000);
config.setTestOnBorrow(true);
config.setTestOnReturn(true);

String ip = &quot;192.168.80.128&quot;;
int port = 6379;
int timeOut = 2000;
String password=&quot;jdd.com&quot;;

jedisPool = new JedisPool(config,ip,port,timeOut,password);</code></pre><p>  }</p>
<p>  public static String set(String key, String value) {</p>
<pre><code>Jedis jedis = jedisPool.getResource();
String result = jedis.set(key, value);
jedis.close();
return result;</code></pre><p>  }</p>
<p>  public static String get(String key) {</p>
<pre><code>Jedis jedis = jedisPool.getResource();
String result = jedis.get(key);
jedis.close();
return result;</code></pre><p>  }</p>
<p>  public static Long hset(String key, String item, String value) {</p>
<pre><code>Jedis jedis = jedisPool.getResource();
Long result = jedis.hset(key, item, value);
jedis.close();
return result;</code></pre><p>  }</p>
<p>  public static String hget(String key, String item) {</p>
<pre><code>Jedis jedis = jedisPool.getResource();
String result = jedis.hget(key, item);
jedis.close();
return result;</code></pre><p>  }</p>
<p>  /**</p>
<ul>
<li><p>Redis Hmget 命令用于返回哈希表中，一个或多个给定字段的值。</p>
</li>
<li><p>如果指定的字段不存在于哈希表，那么返回一个 nil 值。</p>
</li>
<li></li>
<li><p>@param key</p>
</li>
<li><p>@param item</p>
</li>
<li><p>@return 一个包含多个给定字段关联值的表，表值的排列顺序和指定字段的请求顺序一样。</p>
</li>
<li><p>/<br>public static List<String> hmget(String key, String… item) {<br>  Jedis jedis = jedisPool.getResource();<br>  List<String> result = jedis.hmget(key, item);<br>  jedis.close();<br>  return result;<br>}</p>
<p>public static Long incr(String key) {<br>  Jedis jedis = jedisPool.getResource();<br>  Long result = jedis.incr(key);<br>  jedis.close();<br>  return result;<br>}</p>
<p>public static Long decr(String key) {<br>  Jedis jedis = jedisPool.getResource();<br>  Long result = jedis.decr(key);<br>  jedis.close();<br>  return result;<br>}</p>
<p>public static Long expire(String key, int second) {<br>  Jedis jedis = jedisPool.getResource();<br>  Long result = jedis.expire(key, second);<br>  jedis.close();<br>  return result;<br>}</p>
<p>public static Long ttl(String key) {<br>  Jedis jedis = jedisPool.getResource();<br>  Long result = jedis.ttl(key);<br>  jedis.close();<br>  return result;<br>}</p>
<p>public static Long hdel(String key, String item) {<br>  Jedis jedis = jedisPool.getResource();<br>  Long result = jedis.hdel(key, item);<br>  jedis.close();<br>  return result;<br>}</p>
<p>public static Long del(String key) {<br>  Jedis jedis = jedisPool.getResource();<br>  Long result = jedis.del(key);<br>  jedis.close();<br>  return result;<br>}</p>
<p>public static Long rpush(String key, String… strings) {<br>  Jedis jedis = jedisPool.getResource();<br>  Long result = jedis.rpush(key, strings);<br>  jedis.close();<br>  return result;<br>}</p>
<p>/**</p>
</li>
<li><p>Redis Lrange 返回列表中指定区间内的元素，区间以偏移量 START 和 END 指定。 其中 0 表示列表的第一个元素， 1 表示列表的第二个元素，以此类推。</p>
</li>
<li><p>你也可以使用负数下标，以 -1 表示列表的最后一个元素， -2 表示列表的倒数第二个元素，以此类推。</p>
</li>
<li></li>
<li><p>@param string</p>
</li>
<li><p>@param start</p>
</li>
<li><p>@param end</p>
</li>
<li><p>@return</p>
</li>
<li><p>/<br>public static List<String> lrange(String key, int start, int end) {<br>  Jedis jedis = jedisPool.getResource();<br>  List<String> result = jedis.lrange(key, start, end);<br>  jedis.close();<br>  return result;<br>}</p>
<p>/**</p>
</li>
<li><p>从列表中从头部开始移除count个匹配的值。如果count为零，所有匹配的元素都被删除。如果count是负数，内容从尾部开始删除。</p>
</li>
<li></li>
<li><p>@param string</p>
</li>
<li><p>@param string2</p>
</li>
<li><p>@param i</p>
</li>
<li><p>/<br>public static Long lrem(String key, Long count, String value) {<br>  Jedis jedis = jedisPool.getResource();<br>  Long result = jedis.lrem(key, count, value);<br>  jedis.close();<br>  return result;<br>}</p>
<p>/**</p>
</li>
<li><p>Redis Zadd 命令用于将一个或多个成员元素及其分数值加入到有序集当中。</p>
</li>
<li><p>如果某个成员已经是有序集的成员，那么更新这个成员的分数值，并通过重新插入这个成员元素，来保证该成员在正确的位置上。</p>
</li>
<li><p>分数值可以是整数值或双精度浮点数。</p>
</li>
<li><p>如果有序集合 key 不存在，则创建一个空的有序集并执行 ZADD 操作。</p>
</li>
<li><p>当 key 存在但不是有序集类型时，返回一个错误。</p>
</li>
<li></li>
<li><p>@param string</p>
</li>
<li><p>@param i</p>
</li>
<li><p>@param string2</p>
</li>
<li><p>@return 被成功添加的新成员的数量，不包括那些被更新的、已经存在的成员。</p>
</li>
<li><p>/<br>public static Long zadd(String key, double score, String member) {<br>  Jedis jedis = jedisPool.getResource();<br>  Long result = jedis.zadd(key, score, member);<br>  jedis.close();<br>  return result;<br>}</p>
<p>/**</p>
</li>
<li><p>Redis Zrevrangebyscore 返回有序集中指定分数区间内的所有的成员。有序集成员按分数值递减(从大到小)的次序排列。</p>
</li>
<li><p>具有相同分数值的成员按字典序的逆序(reverse lexicographical order )排列。</p>
</li>
<li><p>除了成员按分数值递减的次序排列这一点外， ZREVRANGEBYSCORE 命令的其他方面和 ZRANGEBYSCORE 命令一样。</p>
</li>
<li></li>
<li><p>@param key</p>
</li>
<li><p>@param max</p>
</li>
<li><p>@param min</p>
</li>
<li><p>@param offset</p>
</li>
<li><p>@param count</p>
</li>
<li><p>@return 指定区间内，带有分数值(可选)的有序集成员的列表。</p>
</li>
<li><p>/<br>public static Set<String> zrevrangebyscore(String key, String max, String min, int offset, int count) {<br>  Jedis jedis = jedisPool.getResource();<br>  Set<String> result =  jedis.zrevrangeByScore(key, max, min, offset, count);<br>  jedis.close();<br>  return result;<br>}<br>}</p>
</li>
</ul>
</li>
</ul>
<p><a href="https://www.cnblogs.com/afeng2010/p/10042790.html" target="_blank" rel="noopener">https://www.cnblogs.com/afeng2010/p/10042790.html</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://kuangai.github.io/2020/07/29/LRU%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="wsc">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="study">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/07/29/LRU%E7%AE%97%E6%B3%95/" itemprop="url">LRU算法</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-07-29T19:25:00+08:00">
                2020-07-29
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/redis/" itemprop="url" rel="index">
                    <span itemprop="name">redis</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/redis/%E7%AE%97%E6%B3%95/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>1.1. 原理<br>LRU（Least recently used，最近最少使用）算法根据数据的历史访问记录来进行淘汰数据，其核心思想是“如果数据最近被访问过，那么将来被访问的几率也更高”。</p>
<p>1.2. 实现<br>最常见的实现是使用一个链表保存缓存数据，详细算法实现如下：</p>
<ol>
<li><p>新数据插入到链表头部；</p>
</li>
<li><p>每当缓存命中（即缓存数据被访问），则将数据移到链表头部；</p>
</li>
<li><p>当链表满的时候，将链表尾部的数据丢弃。</p>
</li>
</ol>
<p>1.3. 分析<br>【命中率】</p>
<p>当存在热点数据时，LRU的效率很好，但偶发性的、周期性的批量操作会导致LRU命中率急剧下降，缓存污染情况比较严重。</p>
<p>【复杂度】</p>
<p>实现简单。</p>
<p>【代价】</p>
<p>命中时需要遍历链表，找到命中的数据块索引，然后需要将数据移到头部。</p>
<p>LRU-K<br>2.1. 原理<br>LRU-K中的K代表最近使用的次数，因此LRU可以认为是LRU-1。LRU-K的主要目的是为了解决LRU算法“缓存污染”的问题，其核心思想是将“最近使用过1次”的判断标准扩展为“最近使用过K次”。</p>
<p>2.2. 实现<br>相比LRU，LRU-K需要多维护一个队列，用于记录所有缓存数据被访问的历史。只有当数据的访问次数达到K次的时候，才将数据放入缓存。当需要淘汰数据时，LRU-K会淘汰第K次访问时间距当前时间最大的数据。详细实现如下：</p>
<ol>
<li><p>数据第一次被访问，加入到访问历史列表；</p>
</li>
<li><p>如果数据在访问历史列表里后没有达到K次访问，则按照一定规则（FIFO，LRU）淘汰；</p>
</li>
<li><p>当访问历史队列中的数据访问次数达到K次后，将数据索引从历史队列删除，将数据移到缓存队列中，并缓存此数据，缓存队列重新按照时间排序；</p>
</li>
<li><p>缓存数据队列中被再次访问后，重新排序；</p>
</li>
<li><p>需要淘汰数据时，淘汰缓存队列中排在末尾的数据，即：淘汰“倒数第K次访问离现在最久”的数据。</p>
</li>
</ol>
<p>LRU-K具有LRU的优点，同时能够避免LRU的缺点，实际应用中LRU-2是综合各种因素后最优的选择，LRU-3或者更大的K值命中率会高，但适应性差，需要大量的数据访问才能将历史访问记录清除掉。</p>
<p>2.3. 分析<br>【命中率】</p>
<p>LRU-K降低了“缓存污染”带来的问题，命中率比LRU要高。</p>
<p>【复杂度】</p>
<p>LRU-K队列是一个优先级队列，算法复杂度和代价比较高。</p>
<p>【代价】</p>
<p>由于LRU-K还需要记录那些被访问过、但还没有放入缓存的对象，因此内存消耗会比LRU要多；当数据量很大的时候，内存消耗会比较可观。</p>
<p>LRU-K需要基于时间进行排序（可以需要淘汰时再排序，也可以即时排序），CPU消耗比LRU要高。</p>
<p> Two queues（2Q）<br>3.1. 原理<br>Two queues（以下使用2Q代替）算法类似于LRU-2，不同点在于2Q将LRU-2算法中的访问历史队列（注意这不是缓存数据的）改为一个FIFO缓存队列，即：2Q算法有两个缓存队列，一个是FIFO队列，一个是LRU队列。</p>
<p>3.2. 实现<br>当数据第一次访问时，2Q算法将数据缓存在FIFO队列里面，当数据第二次被访问时，则将数据从FIFO队列移到LRU队列里面，两个队列各自按照自己的方法淘汰数据。详细实现如下：</p>
<ol>
<li><p>新访问的数据插入到FIFO队列；</p>
</li>
<li><p>如果数据在FIFO队列中一直没有被再次访问，则最终按照FIFO规则淘汰；</p>
</li>
<li><p>如果数据在FIFO队列中被再次访问，则将数据移到LRU队列头部；</p>
</li>
<li><p>如果数据在LRU队列再次被访问，则将数据移到LRU队列头部；</p>
</li>
<li><p>LRU队列淘汰末尾的数据。</p>
</li>
</ol>
<p>注：上图中FIFO队列比LRU队列短，但并不代表这是算法要求，实际应用中两者比例没有硬性规定。</p>
<p>3.3. 分析<br>【命中率】</p>
<p>2Q算法的命中率要高于LRU。</p>
<p>【复杂度】</p>
<p>需要两个队列，但两个队列本身都比较简单。</p>
<p>【代价】</p>
<p>FIFO和LRU的代价之和。</p>
<p>2Q算法和LRU-2算法命中率类似，内存消耗也比较接近，但对于最后缓存的数据来说，2Q会减少一次从原始存储读取数据或者计算数据的操作。</p>
<p>Multi Queue（MQ）<br>4.1. 原理<br>MQ算法根据访问频率将数据划分为多个队列，不同的队列具有不同的访问优先级，其核心思想是：优先缓存访问次数多的数据。</p>
<p>4.2. 实现<br>MQ算法将缓存划分为多个LRU队列，每个队列对应不同的访问优先级。访问优先级是根据访问次数计算出来的，例如</p>
<p>详细的算法结构图如下，Q0，Q1….Qk代表不同的优先级队列，Q-history代表从缓存中淘汰数据，但记录了数据的索引和引用次数的队列：</p>
<p>如上图，算法详细描述如下：</p>
<ol>
<li><p>新插入的数据放入Q0；</p>
</li>
<li><p>每个队列按照LRU管理数据；</p>
</li>
<li><p>当数据的访问次数达到一定次数，需要提升优先级时，将数据从当前队列删除，加入到高一级队列的头部；</p>
</li>
<li><p>为了防止高优先级数据永远不被淘汰，当数据在指定的时间里访问没有被访问时，需要降低优先级，将数据从当前队列删除，加入到低一级的队列头部；</p>
</li>
<li><p>需要淘汰数据时，从最低一级队列开始按照LRU淘汰；每个队列淘汰数据时，将数据从缓存中删除，将数据索引加入Q-history头部；</p>
</li>
<li><p>如果数据在Q-history中被重新访问，则重新计算其优先级，移到目标队列的头部；</p>
</li>
<li><p>Q-history按照LRU淘汰数据的索引。</p>
</li>
</ol>
<p>4.3. 分析<br>【命中率】</p>
<p>MQ降低了“缓存污染”带来的问题，命中率比LRU要高。</p>
<p>【复杂度】</p>
<p>MQ需要维护多个队列，且需要维护每个数据的访问时间，复杂度比LRU高。</p>
<p>【代价】</p>
<p>MQ需要记录每个数据的访问时间，需要定时扫描所有队列，代价比LRU要高。</p>
<p>注：虽然MQ的队列看起来数量比较多，但由于所有队列之和受限于缓存容量的大小，因此这里多个队列长度之和和一个LRU队列是一样的，因此队列扫描性能也相近。</p>
<p>LRU类算法对比<br>由于不同的访问模型导致命中率变化较大，此处对比仅基于理论定性分析，不做定量分析。</p>
<p>对比点</p>
<p>对比</p>
<p>命中率</p>
<p>LRU-2 &gt; MQ(2) &gt; 2Q &gt; LRU</p>
<p>复杂度</p>
<p>LRU-2 &gt; MQ(2) &gt; 2Q &gt; LRU</p>
<p>代价</p>
<p>LRU-2  &gt; MQ(2) &gt; 2Q &gt; LRU</p>
<p>实际应用中需要根据业务的需求和对数据的访问情况进行选择，并不是命中率越高越好。例如：虽然LRU看起来命中率会低一些，且存在”缓存污染“的问题，但由于其简单和代价小，实际应用中反而应用更多。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://kuangai.github.io/2020/07/28/%E5%BB%BA%E7%AB%8B%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8E%9F%E5%88%99%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="wsc">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="study">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/07/28/%E5%BB%BA%E7%AB%8B%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8E%9F%E5%88%99%E6%80%BB%E7%BB%93/" itemprop="url">建立索引的原则总结</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-07-28T21:09:00+08:00">
                2020-07-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/mysql/" itemprop="url" rel="index">
                    <span itemprop="name">mysql</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>数据库建立索引的原则 </p>
<p>1，确定针对该表的操作是大量的查询操作还是大量的增删改操作。 </p>
<p>2，尝试建立索引来帮助特定的查询。检查自己的sql语句，为那些频繁在where子句中出现的字段建立索引。 </p>
<p>3，尝试建立复合索引来进一步提高系统性能。修改复合索引将消耗更长时间，同时，复合索引也占磁盘空间。 </p>
<p>4，对于小型的表，建立索引可能会影响性能 </p>
<p>5，应该避免对具有较少值的字段进行索引。 </p>
<p>6，避免选择大型数据类型的列作为索引。 </p>
<p>索引建立的原则 </p>
<p>索引查询是数据库中重要的记录查询方法，要不要进入索引以及在那些字段上建立索引都要和实际数据库系统的查询要求结合来考虑，下面给出实际中的一些通用的原则： </p>
<ol>
<li><p>在经常用作过滤器的字段上建立索引； </p>
</li>
<li><p>在SQL语句中经常进行GROUP BY、ORDER BY的字段上建立索引； </p>
</li>
<li><p>在不同值较少的字段上不必要建立索引，如性别字段； </p>
</li>
<li><p>对于经常存取的列避免建立索引； </p>
</li>
<li><p>用于联接的列（主健/外健）上建立索引； </p>
</li>
<li><p>在经常存取的多个列上建立复合索引，但要注意复合索引的建立顺序要按照使用的频度来确定； </p>
</li>
<li><p>缺省情况下建立的是非簇集索引，但在以下情况下最好考虑簇集索引，如：含有有限数目（不是很少）唯一的列；进行大范围的查询；充分的利用索引可以减少表扫描I/0的次数，有效的避免对整表的搜索。当然合理的索引要建立在对各种查询的分析和预测中，也取决于DBA的所设计的数据库结构。 </p>
</li>
</ol>
<p>oracle 索引建立的若干原则 </p>
<pre><code>我们首先要考虑的是数据量，数据量级别的不同，要考虑的问题有很大区别。几千条记录建不建索引其实都无所谓了，差个几豪秒也感觉不出来，但数据量一旦要增长到百万， 千万级别，索引的重要性就体现出来了。没有索引一个查询可能要几个小时甚至几天才能出来，对数据库的影响不仅仅是查询速度的降低， 在io 上的花费和对数据库连接资源的占用甚至会拖跨数据库。那么怎样建立索引，建立什么类型的索引呢，应该按照几个方面来考虑。 </code></pre><p>1． 先要了解业务需求，总结出应用会按照哪几个字段来进行查询。例如一个人员查询系统可能会按照（姓名，身份证件号码，性别，住址，民族等），当然可能是几个字段的组合查询。 </p>
<p>2． 确定了第一步后要估计数据的分布。相同值有多少，是不是均匀。如姓名字段就会有大量的重复情况；性别可能只有两个值（1，2 分别代表男，女），民族会有56 个。 </p>
<p>3． 确定索引的类型。选择性高的字段建立B- 树索引最好，如果数据量太大，可考虑把索引分区，在并发情况下通常会表现很好。相当于把一棵很大的B树拆开成了多棵小树。只有几个值的字段如性别并且数据分布比较均匀，查询的平均命中率要是非常高就不需要建立索引，否则可以建立位图索引（但会影响并发）。 </p>
<p>oracle建立索引原则 </p>
<p>索引需要平衡query和DML的需要，常用于(子)查询的表应建立索引；<br>把索引建到不同的表空间中；<br>用统一的extent大小:<br>五个block的倍数或者tablespace指定的MINIMUM EXTENT的倍数；<br>创建索引考虑用NOLOGGING参数，重建索引的时候也一样；<br>创建索引时INITRANS值应该比相应的table的值高一些；<br>对常用SQL语句的where条件中的列建立唯一索引或组合索引，组合条件查询中相应的组合索引更有效；<br>对于组合索引，根据列的唯一值概率，安排索引顺序；<br>如果一个列具有很低的数据基数，并且或者可具有空值，不应作为索引列；<br>如果where语句中不得不对查询列采用函数查询，如upper函数，最好建立相应函数索引；<br>对于低基数集的列，并包含OR等逻辑运算，考虑用Bitmap索引，对于从大量行的表中返回大量的行时也可以考虑Bitmap索引；<br>避免在有大量并发DML运算的表中使用Bitmap索引</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://kuangai.github.io/2020/07/27/char%E3%80%81varchar%E3%80%81text%E5%AF%B9%E6%AF%94/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="wsc">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="study">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/07/27/char%E3%80%81varchar%E3%80%81text%E5%AF%B9%E6%AF%94/" itemprop="url">char、varchar、text对比</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-07-27T23:04:00+08:00">
                2020-07-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/mysql/" itemprop="url" rel="index">
                    <span itemprop="name">mysql</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>char的总结：<br>      char最大长度是255字符，注意是字符数和字符集没关系。可以有默认值，尾部有空格会被截断。<br>varchar的总结：<br>      varchar的最大长度65535是指能存储的字节数，其实最多只能存储65532个字节，还有3个字节用于存储长度。注意是字节数这个和字符集有关系。一个汉字字符用utf8占用3字节，用gbk占用2字节。可以有默认值，尾部有空格不会截断。<br>text的总结：<br>      text和varchar基本相同。text会忽略指定的大小这和varchar有所不同，text不能有默认值。尾部有空格不会被截断。text使用额外的2个字节来存储数据的大小，varchar根据存储数据的大小选择用几个字节来存储。text的65535字节全部用来存储数据，varchar则会占用1－3个字节去存储数据大小。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://kuangai.github.io/2020/07/27/Union%E5%92%8CUnion-all%E7%9A%84%E5%8C%BA%E5%88%AB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="wsc">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="study">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/07/27/Union%E5%92%8CUnion-all%E7%9A%84%E5%8C%BA%E5%88%AB/" itemprop="url">Union和Union all的区别</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-07-27T22:56:00+08:00">
                2020-07-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/mysql/" itemprop="url" rel="index">
                    <span itemprop="name">mysql</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>union去重并排序，union all直接返回合并的结果，不去重也不排序；<br>union all比union性能好；</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://kuangai.github.io/2020/07/27/%E4%B8%89%E8%8C%83%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="wsc">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="study">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/07/27/%E4%B8%89%E8%8C%83%E5%BC%8F/" itemprop="url">三范式</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-07-27T21:55:00+08:00">
                2020-07-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/mysql/" itemprop="url" rel="index">
                    <span itemprop="name">mysql</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>三范式<br>满足第三范式（3NF）必须先满足第二范式（2NF）<br>满足第二范式（2NF）必须先满足第一范式（1NF）<br>1NF:字段不可分;<br>2NF:有主键，非主键字段依赖主键;<br>3NF:非主键字段不能相互依赖; </p>
<p>解释:<br>1NF:原子性 字段不可再分,否则就不是关系数据库;<br>2NF:唯一性 一个表只说明一个事物;<br>3NF:每列都与主键有直接关系，不存在传递依赖; </p>
<p>反三范式<br>没有冗余的数据库未必是最好的数据库，有时为了提高运行效率，提高读性能，就必须降低范式标准，适当保留冗余数据。具体做法是： 在概念数据模型设计时遵守第三范式，降低范式标准的工作放到物理数据模型设计时考虑。降低范式就是增加字段，减少了查询时的关联，提高查询效率，因为在数据库的操作中查询的比例要远远大于DML的比例。但是反范式化一定要适度，并且在原本已满足三范式的基础上再做调整的。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://kuangai.github.io/2020/07/27/drop%E3%80%81truncate%E5%92%8Cdelete%E7%9A%84%E5%8C%BA%E5%88%AB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="wsc">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="study">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/07/27/drop%E3%80%81truncate%E5%92%8Cdelete%E7%9A%84%E5%8C%BA%E5%88%AB/" itemprop="url">drop、truncate和delete的区别</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-07-27T21:49:00+08:00">
                2020-07-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/mysql/" itemprop="url" rel="index">
                    <span itemprop="name">mysql</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>（1）DELETE语句执行删除的过程是每次从表中删除一行，并且同时将该行的删除操作作为事务记录在日志中保存以便进行进行回滚操作。</p>
<p>   TRUNCATE TABLE 则一次性地从表中删除所有的数据并不把单独的删除操作记录记入日志保存，删除行是不能恢复的。并且在删除的过程中不会激活与表有关的删除触发器。执行速度快。</p>
<p>（2）表和索引所占空间。</p>
<p>   当表被TRUNCATE 后，这个表和索引所占用的空间会恢复到初始大小，</p>
<p>   DELETE操作不会减少表或索引所占用的空间。</p>
<p>   drop语句将表所占用的空间全释放掉。</p>
<p>（3）一般而言，drop &gt; truncate &gt; delete</p>
<p>（4）应用范围。</p>
<pre><code>TRUNCATE 只能对TABLE；         DELETE可以是table和view</code></pre><p>（5）TRUNCATE 和DELETE只删除数据， DROP则删除整个表（结构和数据）。</p>
<p>（6）truncate与不带where的delete ：只删除数据，而不删除表的结构（定义）drop语句将删除表的结构被依赖的约束（constrain),触发器（trigger)索引（index);依赖于该表的存储过程/函数将被保留，但其状态会变为：invalid。</p>
<p>（7）delete语句为DML（data maintain Language),这个操作会被放到 rollback segment中,事务提交后才生效。如果有相应的 tigger,执行的时候将被触发。</p>
<p>（8）truncate、drop是DLL（data define language),操作立即生效，原数据不放到 rollback segment中，不能回滚</p>
<p>（9）在没有备份情况下，谨慎使用 drop 与 truncate。要删除部分数据行采用delete且注意结合where来约束影响范围。回滚段要足够大。要删除表用drop;若想保留表而将表中数据删除，如果于事务无关，用truncate即可实现。如果和事务有关，或老师想触发trigger,还是用delete。</p>
<p>（10） Truncate table 表名 速度快,而且效率高,因为:<br>truncate table 在功能上与不带 WHERE 子句的 DELETE 语句相同：二者均删除表中的全部行。但 TRUNCATE TABLE 比 DELETE 速度快，且使用的系统和事务日志资源少。DELETE 语句每次删除一行，并在事务日志中为所删除的每行记录一项。TRUNCATE TABLE 通过释放存储表数据所用的数据页来删除数据，并且只在事务日志中记录页的释放。 </p>
<p>（11） TRUNCATE TABLE 删除表中的所有行，但表结构及其列、约束、索引等保持不变。新行标识所用的计数值重置为该列的种子。如果想保留标识计数值，请改用 DELETE。如果要删除表定义及其数据，请使用 DROP TABLE 语句。 </p>
<p>（12） 对于由 FOREIGN KEY 约束引用的表，不能使用 TRUNCATE TABLE，而应使用不带 WHERE 子句的 DELETE 语句。由于 TRUNCATE TABLE 不记录在日志中，所以它不能激活触发器。</p>
<p>一、delete</p>
<p>1、delete是DML，执行delete操作时，每次从表中删除一行，并且同时将该行的的删除操作记录在redo和undo表空间中以便进行回滚（rollback）和重做操作，但要注意表空间要足够大，需要手动提交（commit）操作才能生效，可以通过rollback撤消操作。</p>
<p>2、delete可根据条件删除表中满足条件的数据，如果不指定where子句，那么删除表中所有记录。</p>
<p>3、delete语句不影响表所占用的extent，高水线(high watermark)保持原位置不变。</p>
<p>二、truncate</p>
<p>1、truncate是DDL，会隐式提交，所以，不能回滚，不会触发触发器。</p>
<p>2、truncate会删除表中所有记录，并且将重新设置高水线和所有的索引，缺省情况下将空间释放到minextents个extent，除非使用reuse storage，。不会记录日志，所以执行速度很快，但不能通过rollback撤消操作（如果一不小心把一个表truncate掉，也是可以恢复的，只是不能通过rollback来恢复）。</p>
<p>3、对于外键（foreignkey ）约束引用的表，不能使用 truncate table，而应使用不带 where 子句的 delete 语句。</p>
<p>4、truncatetable不能用于参与了索引视图的表。</p>
<p>三、drop</p>
<p>1、drop是DDL，会隐式提交，所以，不能回滚，不会触发触发器。</p>
<p>2、drop语句删除表结构及所有数据，并将表所占用的空间全部释放。</p>
<p>3、drop语句将删除表的结构所依赖的约束，触发器，索引，依赖于该表的存储过程/函数将保留,但是变为invalid状态。</p>
<p>总结：</p>
<p>1、在速度上，一般来说，drop&gt; truncate &gt; delete。</p>
<p>2、在使用drop和truncate时一定要注意，虽然可以恢复，但为了减少麻烦，还是要慎重。</p>
<p>3、如果想删除部分数据用delete，注意带上where子句，回滚段要足够大；</p>
<p>   如果想删除表，当然用drop； </p>
<p>   如果想保留表而将所有数据删除，如果和事务无关，用truncate即可；</p>
<p>   如果和事务有关，或者想触发trigger，还是用delete；</p>
<p>   如果是整理表内部的碎片，可以用truncate跟上reuse stroage，再重新导入/插入数据。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">&lt;i class&#x3D;&quot;fa fa-angle-right&quot;&gt;&lt;&#x2F;i&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">wsc</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">29</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">12</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">32</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="http://www.cnblogs.com/xingyunblog" target="_blank" title="博客园">
                      
                        <i class="fa fa-fw fa-globe"></i>博客园</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://blog.csdn.net/hadues" target="_blank" title="CSDN">
                      
                        <i class="fa fa-fw fa-globe"></i>CSDN</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">wsc</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>





        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i>访问人数
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      人
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>总访问量
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
